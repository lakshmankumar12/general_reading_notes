Algorithm Analysis
===================

== Asymtotic analysis

=====
n! << 2^n^  << n^3^  << n^2^  << n log n << n << log n << 1
=====

== Sorting and Related Algorithms

=== Counting Inversions

* This is same as merge sort. As part of merging, just count inversions.
* Remember, u should also do sorting alongside.

== Binary Trees


== Terneray Search Tress

* Each node has a data-member (one char - or trie's equivalent), and an optional end-of-word marker.
  The end of word doesn't necessarily imply termination of search. For eg, cat, cats will
  have cat's t having end-of-word, but there is also a cats
* Each Node has a {lo,eq,hi}-kid pointer. I personally want to call it low-peer, high-peer and child
  pointers
* Operations are insert, search, get-next-char, get-next-string, get-all-substrings.

=== Links to read

* http://www.drdobbs.com/database/ternary-search-trees/184410528[Dobbs journal]


== Graphs

* Represents pair-wise relationship among objects
* Terminology
** Vertices or nodes
** Edges
*** Careful. Dont confuse edge (having smaller spelling for a vertex, having a bigger
    spelling!)
** Directed or Undirected edges
*** In directed, first is tail and second is head. That is direction is from tail to head.
** *Cuts*
*** A Cut in a graph is a split of vertices into 2 non-empty groups(A and B).
*** For undirected, Crossing edges are those that have one end-point each in A and B
*** For Directed, Crossing edges are those that have tail in A, head in B
** Parallel edges are those that have same origin and destination vertex. This may
   or may not be meaningful to a given problem
** Typically m is number of edges, and n is number of vertices. (Mnemonic: m>>n, we
   have far more edges than there are vertices. Number of lines in m(3) is more than n(2)!
   Alternatively, m is O(n) to upto O(n^2^) to classify sparse/dense)
** A degree of a vertex, is referred as the number of edges that start out from that
   vertex.


=== Numerical Facts

* If there are n vertices, assuming no parallel edges, there should be minimum of
  n-1 edges to have all the vertices connected (in one line) and utmost ~n~C~2~ = n(n-1)/2
  number of edges (where all edge is connected to the other edge) in a undirected graph
* If there are n vertices in a graph, we can have up 2^n^-2 possible cuts for this graph.
  Each vertex can be in either set A or B independant of the choice of other vertices. We
  just subtract 2 as we can't have all vertices in each set.

=== Graph Representations

==== Adjacency Matrix

* We have nxn matrix (verticesxvertices matrix).
* Each non-primary diagnal represents a possible Edge. Its 0/1 based on if that edge exists.
* Add bells and whistles to what the matrix element is to accomodate directed (+ve/-ve),
  parallel edges, weighted edges
* Super waste of memory for a sparse graph.

==== Adjancenty List

* Algo course style
** Have 2 different lists - one for vertices and one for edges
** They cross reference each other.
*** Each edge points to its 2 vertices. This way edge struct is of fixed size.
*** Each vertex points to all edges incident on it. The vertex thus should have
    a list of edge-pointers.
*** Note that the sum of cross-references from edges to vertices is exactly
    same as vertices to edges. The edges to vertices are exaclty 2 per edge,
    while in vertices to edges, it varies on degree of each vertex.

* Skiena book style
** Kind of a 2D linked list.
** We have a linked-list of vertices.
** For each vertex, we have a list of edges that originate from that vertex.
** For unidirected, the edge appears twice, once is each vertex's list. For directed
  graph, it appears in the vertex which is its tail.
** Here we show the list of vertices as an array and the vertices as linked-list.
+
----
#define MAXV 1000 /* maximum number of vertices */

typedef struct {
  int y;                 /* adjacency info */
  int weight;            /* edge weight, if any */
  struct edgenode *next; /* next edge in list */
} edgenode;

typedef struct {
  edgenode *edges[MAXV+1]; /* adjacency info */
  int degree[MAXV+1];      /* outdegree of each vertex */
  int nvertices;           /* number of vertices in graph */
  int nedges;              /* number of edges in graph */
  bool directed;           /* is the graph directed? */
} graph;
----

The Skienna book style and algo-course styles are kind of same. In both ways, u can
walk over vertices and then for each vertex walk over its edges. Just that the algo-course
suggests to keep the actual vertices and edges separately in lists of their own.

===== Comparision

[options="header"]
|=======================
|Comparison                             | Winner
|Faster to test if (x,y) is in graph?   | adjacency matrices
|Faster to find the degree of a vertex? | adjacency lists
|Less memory on small graphs?           | adjacency lists (m + n) vs. (n2)
|Less memory on big graphs?             | adjacency matrices (a small win)
|Edge insertion or deletion?            | adjacency matrices O(1) vs. O(d)
|Faster to traverse the graph?          | adjacency lists Θ(m + n) vs. Θ(n2)
|Better for most problems?              | adjacency lists
|=======================

=== Graph classifications

* Directed, Undirected
* Sparse, Dense
** Sparse has edge-number closer to the linear bound (n-1), while dense matrix is
   where edge-number is closer to upper bound ~n~C~2~

=== General Algorithms in a Graph

==== Minimum cuts

Given a graph, find the cut that has the minimum number of cross-over edge (Min-cut)
This is useful, to find closesly related vertices in a graph.

===== Karger Algorithm

The solution allows parallel edges for this graph. This goes as follows:

* Keep proceeding till the node-count reduces to 2.
* In every iteration, *randomly* pick an edge and collapse the 2 vertices that
  it connects into one fused-super-vertex. Remove this chosen edge.
* Remove any edges that start and end at same-edge.
* When you are left with 2, all vertices part of each fused/orig vertex is
  the resulting graph-cut.

But this is just a random algo. There is no guarantee that the resulting cut
is a min-cut.

===== Analysis of this algorithem

* If a edge that should remain as part of min-cut, ends up getting randomly
  chosen, then the algo will fail.
* But if run a few times, this algorithem will succeed with a high degree of
  probability.

==== Graph Traversal

* Before traversal, we can mark each node as one of the 3 states
** Undiscovered
** Discovered
** Processed
* Most search graph algorithms consider one vertex as the source/start vertex.

===== Breadth First Traversal

* Note the presence of a Queue in BFS
* It grabs territory layer by layer from source vertex.

.Skienna code
----
BFS(G,s)
  for each vertex u ∈ V [G] − {s} do
    state[u] = "undiscovered"
    p[u] = nil, i.e. no parent is in the BFS tree
  state[s] = "discovered"
  p[s] = nil
  Q = {s}
  while Q ≠ ϕ do
    u = dequeue[Q]                   /* Note that u is already discovered *
    process vertex u as desired       * However processing of u happens now */
    for each v ∈ Adj[u] do
      process edge (u,v) as desired  /* For undirected graph, this edge may be already processed
                                        So, if u want only one time, track that as well */
      if state[v] = "undiscovered" then
        state[v] = "discovered"
        p[v] = u                    /* This parent path from v to source s, is the shortest path from s to v
                                       for undirected graphs. For directed graphs, there may be back-pointing
                                        edges! */

        enqueue[Q,v]
    state[u] = "processed"
----

* Whatever is marked processed at the end of BFS is what is reacheable from s.

*Applications*

* Find all connected nodes to a given graph.
** You can keep all nodes in a bigger outer queue.
** Start with one node, and do a BFS from here. You will pick all nodes that is
   connected with this. Dequeue from outer queue as you meet nodes.
** Keep doing BFS, till outer queue is empty. That way you get all groups in the
   graph.
** This could be done DFS way also (my own observation!)
* Find distance of each vertex from source vertex s.
** This is easily achived by storing the distance in each vertex - as part of processing
   of node.
* Find the path to each vertex from source vertex s.
** If we build the parent of each node info in our BFS, we can use recursive approach
   to build the root from the parent info.
+
----
parents_arr=[...]
find_parent(parents_arr, parent_desired, node)
{
  if ( node == parent || parents_arr[node] == -1) {
    printf("%d",parent_desired);
  } else {
    find_parent(parents_arr, parent_desired, parents_arr[node]);
    printf("%d",node);
  }
}
----
+
* Find if a graphs is bipartite (can you assign vertices either of 2 colors, such
  that no two adjancent vertex is of same color)
** Keep running BFS and see if you can successfully finish BFS.

===== Depth First Traversal

* It just goes all in into one path
* We can technically modify BFS slightly by replaceing Queue with stack, or
  leverage recursion to naturally achieve our stacking.

.Skienna code Vs Standford-algo-course-code
----
time = 0          /* is a global var */    |
DFS(G,u)                                   |    DFS(G,u)
  state[u] = "discovered"                  |     state[u] = "discovered"
  process vertex u if desired              |        ... early_process_vertex ...
  entry[u] = time                          |        ...
  time = time + 1                          |        ...
  for each v ∈ Adj[u] do                   |     for each v ∈ Adj[u] do
    process edge (u,v) if desired          |        ... process_edge (u,v)
    if state[v] = "undiscovered" then      |        if state[v] = "Undiscovered" then
      p[v] = u                             |          ...
      DFS(G,v)                             |          DFS(G,v)
  state[u] = "processed"                   |
  exit[u] = time                           |
  time = time + 1                          |
----

* The notion of parent is looking superfluous to me.
* The time spent at a parent will be a superset of time
  spent at children. Not sure how otherwise time is useful.

====== Applications

* Find cycles
** DFS by its nature, can classify a edge into tree edges and back
   edges. Edge that explores new vertex is a tree edge, while an
   edge that goes back into a ancestor is a back-edge
** A acyclic graph is one, that has no back-edge during a traversal
* Topological sort for directed graph
** Topological sort is the ordering of what should be completed before
   another.
** Topological order is possible only if there are no cycles. Further
   this implies that acyclic graphs should have atleast one sink vertex.
*** *A sink vertex* is a vertex that has no outgoing edges. If there
    are no sink vertices in a graph, then it definitely cyclic.
** You can start DFS at any vertex. You will end up walking all nodes
   from this. But some vertices may have higher precendence(before)
   than the chosen vertex.
** THere are 2 solutions.
*** First
**** Start with a sink vertex(you need to find this some how). Give
     this the value N (no of vertices in graph). This has to be done
     last by definition.
**** Now remove that node from Graph. Repeat the algorithm. (Due to
     loss of this node, there will be new sink vertex(ices) created
*** Second / slick way.
**** This is same as DFS algo. Just have a current-label extra with
     initial value as N, number of edges
**** Start DFS from any node. Once you hit the depth of recursion,
     which is end of for-loop, assign the current-label value to
     that node.
**** This will neatly assign the Nth value for the first sink you
     discover and back-track from there and so on.
+
----
topological_sort(G)
  all vertices = "Undiscovered"
  current_label = N  /* number of vertices */
  for each vertex u
    if u is "Undiscovered":
      DFS(G,u)

DFS(G,u)
 state[u] = "discovered"
 for each v ∈ Adj[u] do
   if state[v] = "Undiscovered" then
      DFS(G,v)
   level-of-u = current_label
   current_label--
----
+
* Articulate edge detection
** Given in skienna.
** I didn't follow it
