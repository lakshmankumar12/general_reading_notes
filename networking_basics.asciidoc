Simple networking facts
========================

Ethernet
---------

* MAC address is 6 octets

List of protocols
-----------------

DataLink
ARP, RARP
IPv4/ICMP, IPv6/ICMPv6,  IGMP (Group management, used for IPv4 for multicasting)
TCP, SCTP, UDP


IP
---

* 4 octets
* Networking/Host part
* Broadcast is when host-part is all-ones.
* ICMP - Internet Control Message Protocol

* IPv4 header
  ** 20 bytes (It has options)
  ** 32 bit address

* IPv6 header
  ** 40 bytes (It has extensions)
  ** 128 bit addreses (16 octets)


UDP
---

* simple, unreliable, datagram protocol

TCP
---

* sophisticated, reliable byte-stream protocol

* Conection Unique by (src-ip,src-port,dest-ip,dest-port)
* SYN can be responded by RST (then connect returns REFUSED), typically when nobody is listening on the port.

* TCP contains algos to measure RTT and know how long to wait for a ACK
* TCP provides flow-control . The receiver can tell how much its willing to get. This is the receive buffer.
  This is the amount of data it has received from peer, but not yet collect by local app.

SYN-options
+++++++++++

* MSS - each end advertises its MSS to its peer.
       (My Q: But what if the intermediate MTU is lesser?)
* Window scale Option.
    Each SYN contains the window-size. Since this is originally 65K, its too small.
    With scale option its now scalled by 14, enabling upto 1G.
* Timestamp:

----
                       CLOSED---------------+                                                       ;
                         |                  |                                                       ;
                  (serv-passive-open)       |                                                       ;
                         |             (client-opn/send-syn)                                        ;
                         V                  |                                                       ;
                       LISTEN               |                                                       ;
                                            |                                                       ;
        (syn-rcvd/send-synack)              V                                                       ;
          SYN_RCVD                      SYN_SENT                                                       ;
                                                                                                    ;
                                                                                                    ;
                      ESTABLISHED         CLOSE_WAIT  (recv-FIN/send-ACK)                           ;
                                                                                                    ;
                                                                                                    ;
                                           LAST_ACK   (app-closes/send-FIN)                         ;
      FIN_WAIT    CLOSING                                                                           ;
                                                                                                    ;
      FIN_WAIT_2  TIME_WAIT                                                                         ;
                                                                                                    ;
                                                                                                    ;
                                                                                                    ;
----

* Note that when we get FIN, we immediately close. However, if we did clsoe (and got FIN too) we wait
  on TIME_WAIT. This is because only one end needs to wait. Thus its chosen for the first intiator
  of the close to wait on this state. (While the other party isn't waiting, the connection per-se
  isn't possible, as still one-party is holding the 4-tuple)
* Timewait state is for 2MSL -> Max Segment LifeTime is 

Nagle Algorithm
++++++++++++++++

* The algo is very simple. At a given point in time, only one outstanding tinygram can be present
  w/o an ack.
* This algo is naturally self-clocking. It accumulates lots of tiny grams in case of delaying
  networks, but kind of becomes non-felt in fast connections.
* Sometimes, this needs to switched off (like in X-window systems, where each tiney mouse-adjustment
  needs to be send for quick feedback). TCP_NODELAY options switches this off.


SCTP
----

* reliable
* message boundaries
* sequenced delivery
* flow-control
* transport level support for multihoming
* provides a way to minimize head-of-line blocking

* Call associations
* Has multiiple streams, each with its own stream identifier

Well known Ports
-----------------

FTP 21 - control (TCP)  Is there a UDP??
    20 - data
SSH 22 - TCP.
Telnet 23
SMTP  25
HTTP 80
NTP 123
HTTPS 443

What all happen when you type a URL In a browser?
-------------------------------------------------


In an extremely rough and simplified sketch, assuming the simplest possible
HTTP request, no proxies, IPv4 and no problems in any step:

1. browser checks cache; if requested object is in cache and is fresh, skip to #9
2. browser asks OS for server's IP address
3. OS makes a DNS lookup and replies the IP address to the browser
4. browser opens a TCP connection to server (this step is much more complex with HTTPS)
5. browser sends the HTTP request through TCP connection
6. browser receives HTTP response and may close the TCP connection, or reuse it for another request
7. browser checks if the response is a redirect or a conditional response (3xx
   result status codes), authorization request (401), error (4xx and 5xx),
   etc.; these are handled differently from normal responses (2xx)
8. if cacheable, response is stored in cache
9. browser decodes response (e.g. if it's gzipped)
10. browser determines what to do with response (e.g. is it a HTML page, is it an image, is it a sound clip?)
11.  browser renders response, or offers a download dialog for unrecognized types

Again, discussion of each of these points have filled countless pages; take
this only as a short summary. Also, there are many other things happening in
parallel to this (processing typed-in address, speculative prefetching, adding
page to browser history, displaying progress to user, notifying plugins and
extensions, rendering the page while it's downloading, pipelining,
connection tracking for keep-alive, checking for malicious content etc.) -
and the whole operation gets an order of magnitude more complex with HTTPS
(certificates and ciphers and pinning, oh my!).


Generally in a host/router
-------------------

----
            IN-FROM-WIRE
               |
               |
               v
            LOCAL IP   --> FORWARD -> WIRE
               |
               |
               v
            PROCESS
(to draw fully)
----


Socket programming call sequence
-------------------------------

socket
  int socket(int domain, int type, int protocol);
    domain - AF_INET, AF_INET6
    type - SOCK_STREAM, SOCK_DGRAM, SOCK_SEQPACKET, SOCK_RAW (SOCK_NONBLOCK, SOCK_CLOEXEC may also be bit-OREed)
    protocol - IPPROTO_TCP/IPPROTO_UCP/IPPROTO_SCTP
    INET/6, STREAM - TCP/SCTP
    INET/6, DGRAM  - UDP
    INET/6, SEQPACKET  - SCTP
    INET/6, RAW - IPv4,IPv6
    LOCAL, STREAM/DGRAM/SEQPACKET  - Yes
    ROUTE, RAW - Yes   (Kernel routing table)
    KEY, RAW - Yes     (Cryptography)
bind
  int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
    * Used to bind the local addr to listend in case of servers.
    * Used for clients? Not needed the kernel picks a ephemeral port and some local ip.
      If you desire to pick one, u can use bind
listen
  int listen(int sockfd, int backlog);
    returns immdly. backlock is the number of pending connections.
accept
  int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
  int accept4(int sockfd, struct sockaddr *addr, socklen_t *addrlen, int flags);
    * returns the fd of the new connection. The addr is a o/p field that stores the addr of the remote party
    * may block or not block depending on connection availble.
    * in case of tcp, only fully handshaked connections are notified in accept.
connect
  int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
    * connects to a remote server mentioned.
    * For TCP/SCTP initiates the association. No response to handshacke, it returns timeout
    * For UDP, creates the default dest addr. (can be changed by another call to connect)
shutdown
  int shutdown(int sockfd, int how);
    *
close
  int close(int fd);
    * closes the fd, w.r.t this process.
    * Upon all process counts to this fd comign to 0,
      The kernel however will flush all to-send data and send FIN
send
receive


Server:
  socket, bind, listen, accept,   read/write,

Client:
  socket, optional-bind, connect,   read/write,


